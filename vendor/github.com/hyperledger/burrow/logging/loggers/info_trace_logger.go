// Copyright 2017 Monax Industries Limited
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package loggers

import (
	"github.com/eapache/channels"
	kitlog "github.com/go-kit/kit/log"
	"github.com/hyperledger/burrow/logging/structure"
	"github.com/hyperledger/burrow/logging/types"
)

type infoTraceLogger struct {
	infoContext        kitlog.Logger
	traceContext       kitlog.Logger
	outputLogger       *kitlog.SwapLogger
	outputLoggerErrors channels.Channel
}

// Interface assertions
var _ types.InfoTraceLogger = (*infoTraceLogger)(nil)
var _ kitlog.Logger = (types.InfoTraceLogger)(nil)

// Create an InfoTraceLogger by passing the initial outputLogger.
func NewInfoTraceLogger(outputLogger kitlog.Logger) (types.InfoTraceLogger, channels.Channel) {
	// We will never halt the progress of a log emitter. If log output takes too
	// long will start dropping log lines by using a ring buffer.
	swapLogger := new(kitlog.SwapLogger)
	swapLogger.Swap(outputLogger)
	wrappedOutputLogger, errCh := wrapOutputLogger(swapLogger)
	return &infoTraceLogger{
		outputLogger:       swapLogger,
		outputLoggerErrors: errCh,
		// logging contexts
		infoContext: kitlog.With(wrappedOutputLogger,
			structure.ChannelKey, types.InfoChannelName,
		),
		traceContext: kitlog.With(wrappedOutputLogger,
			structure.ChannelKey, types.TraceChannelName,
		),
	}, errCh
}

func NewNoopInfoTraceLogger() types.InfoTraceLogger {
	logger, _ := NewInfoTraceLogger(nil)
	return logger
}

func (l *infoTraceLogger) With(keyvals ...interface{}) types.InfoTraceLogger {
	return &infoTraceLogger{
		outputLogger: l.outputLogger,
		infoContext:  kitlog.With(l.infoContext, keyvals...),
		traceContext: kitlog.With(l.traceContext, keyvals...),
	}
}

func (l *infoTraceLogger) WithPrefix(keyvals ...interface{}) types.InfoTraceLogger {
	return &infoTraceLogger{
		outputLogger: l.outputLogger,
		infoContext:  kitlog.WithPrefix(l.infoContext, keyvals...),
		traceContext: kitlog.WithPrefix(l.traceContext, keyvals...),
	}
}

func (l *infoTraceLogger) Info(keyvals ...interface{}) error {
	return l.infoContext.Log(keyvals...)
}

func (l *infoTraceLogger) Trace(keyvals ...interface{}) error {
	return l.traceContext.Log(keyvals...)
}

func (l *infoTraceLogger) SwapOutput(infoLogger kitlog.Logger) {
	l.outputLogger.Swap(infoLogger)
}

// If logged to as a plain kitlog logger presume the message is for Trace
// This favours keeping Info reasonably quiet. Note that an InfoTraceLogger
// aware adapter can make its own choices, but we tend to think of logs from
// dependencies as less interesting than logs generated by us or specifically
// routed by us.
func (l *infoTraceLogger) Log(keyvals ...interface{}) error {
	return l.Trace(keyvals...)
}

// Wrap the output loggers with a a set of standard transforms, a non-blocking
// ChannelLogger and an outer context
func wrapOutputLogger(outputLogger kitlog.Logger) (kitlog.Logger, channels.Channel) {
	return NonBlockingLogger(VectorValuedLogger(SortLogger(BurrowFormatLogger(outputLogger),
		structure.ChannelKey, structure.MessageKey, structure.TimeKey, structure.ComponentKey)))
}
